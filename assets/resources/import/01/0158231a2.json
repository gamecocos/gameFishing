[1,["21Ht3zxT1G44wJwb845kTi","ecpdLyjvZBwrvm+cedCcQy","eenfLN3BxPp572slPu6BdG","26ixr/KZpHNZ9cWqjU1ReI","64foc/4O1M54TLnk1PiiEf","f2ZRgDgMNGZb2BKtlGoS3s","a8bohkU5BEP7Qbs46dWExD","43oi8YcvxDmbWugwVwWGH0","eex5X39qJC4Zn2J2L2Y7UI","ddPY94m3lMp5v3egn3s0EI","e9aCzRoZxPy62MzxeDuAXm","34WkjDwAxF0rbJsaxJ9GZi","7cJLV+6BlPyajSsGz2G3gt","419NR01wdFu6+TY3Vz+S1U","2eWynZ3V5PPZLp5YB0WzvI","d0yAtd0hJOdYWBI+wTPrOk","96OJedYrNOW63qetcG5m5l"],["_effectAsset","root","node","data","default","grayMaterial","oldPhoto","glowInner","mosaic","roundCornerCrop","flashLight","flag","gaussian"],[["cc.EffectAsset",["_name","shaders","techniques"],0],["cc.Material",["_name","_techniqueData"],1],["cc.Material",["_name","_techniqueData"],2,11],["cc.Prefab",["_name"],2],["cc.Node",["_name","_components","_prefab"],2,9,4],["7c56cZwawZM8aYGevYiajy2",["node","default","grayMaterial","oldPhoto","glowInner","mosaic","roundCornerCrop","flashLight","flag","gaussian"],3,1,6,6,6,6,6,6,6,6,6],["cc.PrefabInfo",["fileId","root"],2,1]],[[0,0,1,2,4],[1,0,1,3],[2,0,1,2],[3,0,2],[4,0,1,2,2],[5,0,1,2,3,4,5,6,7,8,9,1],[6,0,1,2]],[[[[0,"sprite-old-photo",[{"hash":949504733,"record":null,"name":"sprite-old-photo|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_OLD_PHOTO\nuniform OldPhoto {\n  float oldLevel;\n};\nvec4 getOldPhotoColor(vec4 color) {\n  float r = 0.393 * color.r + 0.769 * color.g + 0.189 * color.b;\n  float g = 0.349 * color.r + 0.686 * color.g + 0.168 * color.b;\n  float b = 0.272 * color.r + 0.534 * color.g + 0.131 * color.b;\n  return vec4(r, g, b, color.a);\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_OLD_PHOTO\n  vec4 srcColor = o;\n  vec4 oldColor = getOldPhotoColor(srcColor);\n  o = srcColor + (oldColor - srcColor) * oldLevel;\n  #endif\n  gl_FragColor = o;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_OLD_PHOTO\nuniform float oldLevel;\nvec4 getOldPhotoColor(vec4 color) {\n  float r = 0.393 * color.r + 0.769 * color.g + 0.189 * color.b;\n  float g = 0.349 * color.r + 0.686 * color.g + 0.168 * color.b;\n  float b = 0.272 * color.r + 0.534 * color.g + 0.131 * color.b;\n  return vec4(r, g, b, color.a);\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_OLD_PHOTO\n  vec4 srcColor = o;\n  vec4 oldColor = getOldPhotoColor(srcColor);\n  o = srcColor + (oldColor - srcColor) * oldLevel;\n  #endif\n  gl_FragColor = o;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_OLD_PHOTO","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"OldPhoto","binding":1,"members":[{"name":"oldLevel","type":13,"count":1}],"defines":["USE_OLD_PHOTO"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-old-photo|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"oldLevel":{"type":13,"value":[1],"editor":{"tooltip":"老化程度","range":[0,1]}}}}]}]]],0,0,[],[],[]],[[[1,"sprite-old-photo",{"0":{"defines":{"USE_TEXTURE":true,"USE_OLD_PHOTO":true}}}]],0,0,[0],[0],[0]],[[[3,"ShaderMaterialPrefab"],[4,"ShaderMaterialPrefab",[[5,-2,0,1,2,3,4,5,6,7,8]],[6,"77Mjb0BDlKDqvb+klDkQYh",-1]]],0,[0,1,1,0,2,1,0,3,1,2],[0,0,0,0,0,0,0,0,0],[4,5,6,7,8,9,10,11,12],[1,2,3,4,5,6,7,8,9]],[[[0,"sprite-gray",[{"hash":910976928,"record":null,"name":"sprite-gray|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_GRAY\nuniform GrayPhoto {\n  float grayLevel;\n};\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_GRAY\n  vec4 srcColor = o;\n  float gray = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n  vec4 grayColor = vec4(gray, gray, gray, o.a);\n  o = srcColor + (grayColor - srcColor) * grayLevel;\n  #endif\n  gl_FragColor = o;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_GRAY\nuniform float grayLevel;\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_GRAY\n  vec4 srcColor = o;\n  float gray = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n  vec4 grayColor = vec4(gray, gray, gray, o.a);\n  o = srcColor + (grayColor - srcColor) * grayLevel;\n  #endif\n  gl_FragColor = o;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_GRAY","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"GrayPhoto","binding":1,"members":[{"name":"grayLevel","type":13,"count":1}],"defines":["USE_GRAY"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-gray|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"grayLevel":{"type":13,"value":[1],"editor":{"tooltip":"灰化程度","range":[0,1]}}}}]}]]],0,0,[],[],[]],[[[0,"sprite-glow-inner",[{"hash":3426907229,"record":null,"name":"sprite-glow-inner|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if SHOW_INNER_GLOW\nuniform glow {\n  vec4 glowColor;\n  float glowColorSize;\n  float glowThreshold;\n};\nvec4 getTextureColor(sampler2D texture, vec2 v_uv0) {\n  if (v_uv0.x > 1.0 || v_uv0.x < 0.0 || v_uv0.y > 1.0 || v_uv0.y < 0.0) {\n    return vec4(0.0, 0.0, 0.0, 0.0);\n  }\n  return texture(texture, v_uv0);\n}\nfloat getColorAlpha(float angle, float dist) {\n  float radian = radians(angle);\n  vec4 color = getTextureColor(texture, v_uv0 + vec2(dist * cos(radian), dist * sin(radian)));\n  return color.a;\n}\nfloat getAverageAlpha(float dist) {\n  float totalAlpha = 0.0;\n  totalAlpha += getColorAlpha(0.0, dist);\n  totalAlpha += getColorAlpha(30.0, dist);\n  totalAlpha += getColorAlpha(60.0, dist);\n  totalAlpha += getColorAlpha(90.0, dist);\n  totalAlpha += getColorAlpha(120.0, dist);\n  totalAlpha += getColorAlpha(150.0, dist);\n  totalAlpha += getColorAlpha(180.0, dist);\n  totalAlpha += getColorAlpha(210.0, dist);\n  totalAlpha += getColorAlpha(240.0, dist);\n  totalAlpha += getColorAlpha(270.0, dist);\n  totalAlpha += getColorAlpha(300.0, dist);\n  totalAlpha += getColorAlpha(330.0, dist);\n  return totalAlpha * 0.0833;\n}\nfloat getGlowAlpha() {\n  if (glowColorSize == 0.0) {\n    return 0.0;\n  }\n  vec4 srcColor = getTextureColor(texture, v_uv0);\n  if (srcColor.a <= glowThreshold) {\n    return srcColor.a;\n  }\n  float totalAlpha = 0.0;\n  totalAlpha += getAverageAlpha(glowColorSize * 0.1);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.2);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.3);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.4);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.5);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.6);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.7);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.8);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.9);\n  totalAlpha += getAverageAlpha(glowColorSize * 1.0);\n  return totalAlpha * 0.1;\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n  #if SHOW_INNER_GLOW\n    vec4 color_dest = o;\n    float alpha = getGlowAlpha();\n    if (alpha > glowThreshold) {\n      alpha = 1.0 - alpha;\n      alpha = -1.0 * (alpha - 1.0) * (alpha - 1.0) * (alpha - 1.0) * (alpha - 1.0) + 1.0;\n    }\n    vec4 color_src = glowColor * alpha;\n    gl_FragColor = color_src * color_src.a + color_dest;\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if SHOW_INNER_GLOW\nuniform vec4 glowColor;\nuniform float glowColorSize;\nuniform float glowThreshold;\nvec4 getTextureColor(sampler2D texture, vec2 v_uv0) {\n  if (v_uv0.x > 1.0 || v_uv0.x < 0.0 || v_uv0.y > 1.0 || v_uv0.y < 0.0) {\n    return vec4(0.0, 0.0, 0.0, 0.0);\n  }\n  return texture2D(texture, v_uv0);\n}\nfloat getColorAlpha(float angle, float dist) {\n  float radian = radians(angle);\n  vec4 color = getTextureColor(texture, v_uv0 + vec2(dist * cos(radian), dist * sin(radian)));\n  return color.a;\n}\nfloat getAverageAlpha(float dist) {\n  float totalAlpha = 0.0;\n  totalAlpha += getColorAlpha(0.0, dist);\n  totalAlpha += getColorAlpha(30.0, dist);\n  totalAlpha += getColorAlpha(60.0, dist);\n  totalAlpha += getColorAlpha(90.0, dist);\n  totalAlpha += getColorAlpha(120.0, dist);\n  totalAlpha += getColorAlpha(150.0, dist);\n  totalAlpha += getColorAlpha(180.0, dist);\n  totalAlpha += getColorAlpha(210.0, dist);\n  totalAlpha += getColorAlpha(240.0, dist);\n  totalAlpha += getColorAlpha(270.0, dist);\n  totalAlpha += getColorAlpha(300.0, dist);\n  totalAlpha += getColorAlpha(330.0, dist);\n  return totalAlpha * 0.0833;\n}\nfloat getGlowAlpha() {\n  if (glowColorSize == 0.0) {\n    return 0.0;\n  }\n  vec4 srcColor = getTextureColor(texture, v_uv0);\n  if (srcColor.a <= glowThreshold) {\n    return srcColor.a;\n  }\n  float totalAlpha = 0.0;\n  totalAlpha += getAverageAlpha(glowColorSize * 0.1);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.2);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.3);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.4);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.5);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.6);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.7);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.8);\n  totalAlpha += getAverageAlpha(glowColorSize * 0.9);\n  totalAlpha += getAverageAlpha(glowColorSize * 1.0);\n  return totalAlpha * 0.1;\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n  #if SHOW_INNER_GLOW\n    vec4 color_dest = o;\n    float alpha = getGlowAlpha();\n    if (alpha > glowThreshold) {\n      alpha = 1.0 - alpha;\n      alpha = -1.0 * (alpha - 1.0) * (alpha - 1.0) * (alpha - 1.0) * (alpha - 1.0) + 1.0;\n    }\n    vec4 color_src = glowColor * alpha;\n    gl_FragColor = color_src * color_src.a + color_dest;\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"SHOW_INNER_GLOW","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"glow","binding":1,"members":[{"name":"glowColor","type":16,"count":1},{"name":"glowColorSize","type":13,"count":1},{"name":"glowThreshold","type":13,"count":1}],"defines":["SHOW_INNER_GLOW"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-glow-inner|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"glowColor":{"type":16,"value":[1,1,0,1],"editor":{"type":"color","tooltip":"发光颜色"}},"glowColorSize":{"type":13,"value":[0.2],"editor":{"tooltip":"发光宽度","range":[0,1]}},"glowThreshold":{"type":13,"value":[0.1],"editor":{"tooltip":"发光阈值","range":[0,1]}}}}]}]]],0,0,[],[],[]],[[[0,"sprite-gaussian-blur-v1",[{"hash":4170075038,"record":null,"name":"sprite-gaussian-blur-v1|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if ENABLE_GAUSSIAN_BLUR\nuniform GaussianBlur {\n  vec2 textureSize;\n};\nfloat getWeight(float x, float y) {\n  return (1.0 / (2.0 * 3.141592653589793 * pow(1.5, 2.0))) * pow(1.0 / 2.718281828459045, (pow(x, 2.0) + pow(y, 2.0)) / (2.0 * pow(1.5, 2.0)));\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n  #if ENABLE_GAUSSIAN_BLUR\n    const float size = floor(1.5 * 6.0 + 1.0);\n    const float halfSize = floor(size / 2.0);\n    float totalWeight = getWeight(0.0, 0.0);\n    for(float x = 1.0; x <= halfSize; x++) {\n        totalWeight += getWeight(x, 0.0) * 2.0;\n    }\n    for(float y = 1.0; y <= halfSize; y++) {\n        totalWeight += getWeight(0.0, y) * 2.0;\n    }\n    for(float x = 1.0; x <= halfSize; x++) {\n      for (float y = 1.0; y<= halfSize; y++) {\n        totalWeight += getWeight(x, y) * 4.0;\n      }\n    }\n    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n    float onePxWidth = 1.0 / textureSize.x;\n    float onePxHeight = 1.0 / textureSize.y;\n    for(float x = -halfSize; x<= halfSize; x++) {\n      for (float y = -halfSize; y<= halfSize; y++) {\n        float weight = getWeight(x, y) / totalWeight;\n        finalColor += texture(texture, v_uv0 + vec2(onePxWidth * x, onePxHeight * y)) * weight;\n      }\n    }\n    gl_FragColor = finalColor;\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if ENABLE_GAUSSIAN_BLUR\nuniform vec2 textureSize;\nfloat getWeight(float x, float y) {\n  return (1.0 / (2.0 * 3.141592653589793 * pow(1.5, 2.0))) * pow(1.0 / 2.718281828459045, (pow(x, 2.0) + pow(y, 2.0)) / (2.0 * pow(1.5, 2.0)));\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n  #if ENABLE_GAUSSIAN_BLUR\n    const float size = floor(1.5 * 6.0 + 1.0);\n    const float halfSize = floor(size / 2.0);\n    float totalWeight = getWeight(0.0, 0.0);\n    for(float x = 1.0; x <= halfSize; x++) {\n        totalWeight += getWeight(x, 0.0) * 2.0;\n    }\n    for(float y = 1.0; y <= halfSize; y++) {\n        totalWeight += getWeight(0.0, y) * 2.0;\n    }\n    for(float x = 1.0; x <= halfSize; x++) {\n      for (float y = 1.0; y<= halfSize; y++) {\n        totalWeight += getWeight(x, y) * 4.0;\n      }\n    }\n    vec4 finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n    float onePxWidth = 1.0 / textureSize.x;\n    float onePxHeight = 1.0 / textureSize.y;\n    for(float x = -halfSize; x<= halfSize; x++) {\n      for (float y = -halfSize; y<= halfSize; y++) {\n        float weight = getWeight(x, y) / totalWeight;\n        finalColor += texture2D(texture, v_uv0 + vec2(onePxWidth * x, onePxHeight * y)) * weight;\n      }\n    }\n    gl_FragColor = finalColor;\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ENABLE_GAUSSIAN_BLUR","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"GaussianBlur","binding":1,"members":[{"name":"textureSize","type":14,"count":1}],"defines":["ENABLE_GAUSSIAN_BLUR"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-gaussian-blur-v1|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"textureSize":{"type":14,"value":[100,100],"editor":{"tooltip":"纹理尺寸px（宽 x 高）"}}}}]}]]],0,0,[],[],[]],[[[2,"sprite-flash-light",[{},"0",11,[{"defines":{"USE_TEXTURE":true,"ENABLE_LIGHT":true}},"props",11,[{"lightAngle":36,"lightWidth":0.2},"lightColor",8,[4,4278253055]]]]]],0,0,[0],[0],[10]],[[[1,"sprite-glow-inner",{"0":{"defines":{"USE_TEXTURE":true,"SHOW_INNER_GLOW":true}}}]],0,0,[0],[0],[11]],[[[0,"sprite-round-corner-crop-v2",[{"hash":908960799,"record":null,"name":"sprite-round-corner-crop-v2|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if ENABLE_ROUNDCORNER\nuniform RoundCorner {\n  float xRadius;\n  float yRadius;\n};\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if ENABLE_ROUNDCORNER\n  float ellipseXRadius = clamp(0.0, 0.5, xRadius);\n  float ellipseYRadius = clamp(0.0, 0.5, yRadius);\n  vec2 uv = v_uv0.xy - vec2(0.5, 0.5);\n  float rx = abs(uv.x) - (0.5 - ellipseXRadius);\n  float ry = abs(uv.y) - (0.5 - ellipseYRadius);\n  float mx = step(0.5 - ellipseXRadius, abs(uv.x));\n  float my = step(0.5 - ellipseYRadius, abs(uv.y));\n  float isOutOfEllipse = step(1.0, pow(rx, 2.0) / pow(xRadius, 2.0) + pow(ry, 2.0) / pow(yRadius, 2.0));\n  float angleInRadian = atan(ry / rx);\n  vec2 pointInEllipse = vec2(xRadius * cos(angleInRadian), yRadius * sin(angleInRadian));\n  vec2 pointInBigEllipse = vec2((xRadius * 1.01) * cos(angleInRadian), (yRadius * 1.01)* sin(angleInRadian));\n  float maxDis = distance(pointInBigEllipse, pointInEllipse);\n  float curDis = distance(vec2(rx, ry), pointInEllipse);\n  float smo = smoothstep(0.0, maxDis, curDis);\n  float alpha = 1.0 - mx * my * isOutOfEllipse * smo;\n  o = vec4(o.rgb, o.a * alpha);\n  #endif\n  gl_FragColor = o;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if ENABLE_ROUNDCORNER\nuniform float xRadius;\nuniform float yRadius;\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if ENABLE_ROUNDCORNER\n  float ellipseXRadius = clamp(0.0, 0.5, xRadius);\n  float ellipseYRadius = clamp(0.0, 0.5, yRadius);\n  vec2 uv = v_uv0.xy - vec2(0.5, 0.5);\n  float rx = abs(uv.x) - (0.5 - ellipseXRadius);\n  float ry = abs(uv.y) - (0.5 - ellipseYRadius);\n  float mx = step(0.5 - ellipseXRadius, abs(uv.x));\n  float my = step(0.5 - ellipseYRadius, abs(uv.y));\n  float isOutOfEllipse = step(1.0, pow(rx, 2.0) / pow(xRadius, 2.0) + pow(ry, 2.0) / pow(yRadius, 2.0));\n  float angleInRadian = atan(ry / rx);\n  vec2 pointInEllipse = vec2(xRadius * cos(angleInRadian), yRadius * sin(angleInRadian));\n  vec2 pointInBigEllipse = vec2((xRadius * 1.01) * cos(angleInRadian), (yRadius * 1.01)* sin(angleInRadian));\n  float maxDis = distance(pointInBigEllipse, pointInEllipse);\n  float curDis = distance(vec2(rx, ry), pointInEllipse);\n  float smo = smoothstep(0.0, maxDis, curDis);\n  float alpha = 1.0 - mx * my * isOutOfEllipse * smo;\n  o = vec4(o.rgb, o.a * alpha);\n  #endif\n  gl_FragColor = o;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ENABLE_ROUNDCORNER","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"RoundCorner","binding":1,"members":[{"name":"xRadius","type":13,"count":1},{"name":"yRadius","type":13,"count":1}],"defines":["ENABLE_ROUNDCORNER"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-round-corner-crop-v2|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"xRadius":{"type":13,"value":[0.4],"editor":{"tooltip":"圆角x轴半径长度（相对于纹理宽度）"}},"yRadius":{"type":13,"value":[0.4],"editor":{"tooltip":"圆角y轴半径长度（相对于纹理高度）"}}}}]}]]],0,0,[],[],[]],[[[0,"sprite-mosaic",[{"hash":311370418,"record":null,"name":"sprite-mosaic|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_MOSAIC\nuniform Mosaic {\n  float xBlockCount;\n  float yBlockCount;\n};\nvec2 getUvMapPos() {\n  float xCount;\n  if (xBlockCount <= 0.0) {\n    xCount = 1.0;\n  } else {\n    xCount = xBlockCount;\n  }\n  float blockWidth = 1.0 / xCount;\n  float blockXIndex = floor(v_uv0.x / blockWidth);\n  float yCount;\n  if (yBlockCount <= 0.0) {\n    yCount = 1.0;\n  } else {\n    yCount = yBlockCount;\n  }\n  float blockHeight = 1.0 / yCount;\n  float blockYIndex = floor(v_uv0.y / blockHeight);\n  return vec2(blockWidth * (blockXIndex + 0.5), blockHeight * (blockYIndex + 0.5));\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec2 realPos = v_uv0;\n  #if USE_MOSAIC\n  realPos = getUvMapPos();\n  #endif\n  #if USE_TEXTURE\n  o *= texture(texture, realPos);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, realPos + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if USE_MOSAIC\nuniform float xBlockCount;\nuniform float yBlockCount;\nvec2 getUvMapPos() {\n  float xCount;\n  if (xBlockCount <= 0.0) {\n    xCount = 1.0;\n  } else {\n    xCount = xBlockCount;\n  }\n  float blockWidth = 1.0 / xCount;\n  float blockXIndex = floor(v_uv0.x / blockWidth);\n  float yCount;\n  if (yBlockCount <= 0.0) {\n    yCount = 1.0;\n  } else {\n    yCount = yBlockCount;\n  }\n  float blockHeight = 1.0 / yCount;\n  float blockYIndex = floor(v_uv0.y / blockHeight);\n  return vec2(blockWidth * (blockXIndex + 0.5), blockHeight * (blockYIndex + 0.5));\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec2 realPos = v_uv0;\n  #if USE_MOSAIC\n  realPos = getUvMapPos();\n  #endif\n  #if USE_TEXTURE\n  o *= texture2D(texture, realPos);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, realPos + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"USE_MOSAIC","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"Mosaic","binding":1,"members":[{"name":"xBlockCount","type":13,"count":1},{"name":"yBlockCount","type":13,"count":1}],"defines":["USE_MOSAIC"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-mosaic|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"xBlockCount":{"type":13,"value":[30],"editor":{"tooltip":"X轴方向马赛克方块数量"}},"yBlockCount":{"type":13,"value":[30],"editor":{"tooltip":"Y轴方向马赛克方块数量"}}}}]}]]],0,0,[],[],[]],[[[1,"sprite-round-corner-crop-v2",{"0":{"props":{"xRadius":0.2,"yRadius":0.2},"defines":{"USE_TEXTURE":true,"ENABLE_ROUNDCORNER":true}}}]],0,0,[0],[0],[12]],[[[0,"sprite-flag",[{"hash":54660402,"record":null,"name":"sprite-flag|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nin vec3 a_position;\nuniform LAMYOUMG_COM {\n  float textureWidth;\n  float speed;\n  float amplitude;\n  float wave;\n  vec2 startPos;\n};\n#if USE_TEXTURE\n  in mediump vec2 a_uv0;\n  out mediump vec2 v_uv0;\n#endif\nvoid main () {\n  float angleSpanH = wave * 3.14159265;\n  float pz = amplitude * sin(cc_time.x * speed - (a_position.x - startPos.x + a_position.y - startPos.y) / textureWidth * angleSpanH);\n  vec4 position = vec4(a_position.x, a_position.y + pz, a_position.z, 1);\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  gl_Position = cc_matViewProj * cc_matWorld * position;\n}","frag":"uniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nprecision highp float;\n#if USE_TEXTURE\n  in vec2 v_uv0;\n  uniform sampler2D texture;\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(texture, v_uv0);\n  #endif\n  gl_FragColor = o;\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matWorld;\nuniform mat4 cc_matViewProj;\nuniform vec4 cc_time;\nattribute vec3 a_position;\nuniform float textureWidth;\nuniform float speed;\nuniform float amplitude;\nuniform float wave;\nuniform vec2 startPos;\n#if USE_TEXTURE\n  attribute mediump vec2 a_uv0;\n  varying mediump vec2 v_uv0;\n#endif\nvoid main () {\n  float angleSpanH = wave * 3.14159265;\n  float pz = amplitude * sin(cc_time.x * speed - (a_position.x - startPos.x + a_position.y - startPos.y) / textureWidth * angleSpanH);\n  vec4 position = vec4(a_position.x, a_position.y + pz, a_position.z, 1);\n  #if USE_TEXTURE\n    v_uv0 = a_uv0;\n  #endif\n  gl_Position = cc_matViewProj * cc_matWorld * position;\n}","frag":"\nprecision highp float;\n#if USE_TEXTURE\n  varying vec2 v_uv0;\n  uniform sampler2D texture;\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(texture, v_uv0);\n  #endif\n  gl_FragColor = o;\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]}],"blocks":[{"name":"LAMYOUMG_COM","binding":0,"members":[{"name":"textureWidth","type":13,"count":1},{"name":"speed","type":13,"count":1},{"name":"amplitude","type":13,"count":1},{"name":"wave","type":13,"count":1},{"name":"startPos","type":14,"count":1}],"defines":[]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-flag|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"textureWidth":{"type":13,"value":[600]},"speed":{"type":13,"value":[10]},"amplitude":{"type":13,"value":[5]},"wave":{"type":13,"value":[5]},"startPos":{"type":14,"value":[0,0]}}}]}]]],0,0,[],[],[]],[[[1,"sprite-gaussian-blur-v1",{"0":{"defines":{"USE_TEXTURE":true,"ENABLE_GAUSSIAN_BLUR":true}}}]],0,0,[0],[0],[13]],[[[0,"sprite-flash-light",[{"hash":3415657189,"record":null,"name":"sprite-flash-light|vs|fs","glsl3":{"vert":"\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if ENABLE_LIGHT\nuniform Light {\n  vec4 lightColor;\n  vec2 lightCenterPoint;\n  float lightAngle;\n  float lightWidth;\n  float enableGradient;\n  float cropAlpha;\n  float enableFog;\n};\nvec4 addLightColor(vec4 textureColor, vec4 lightColor, vec2 lightCenterPoint, float lightAngle, float lightWidth) {\n  if (lightWidth <= 0.0) {\n    return textureColor;\n  }\n  float angleInRadians = radians(lightAngle);\n  float dis = 0.0;\n  if (mod(lightAngle, 180.0) != 0.0) {\n    float lightOffsetX = lightCenterPoint.x - ((1.0 - lightCenterPoint.y) / tan(angleInRadians));\n    float dx = lightOffsetX + (1.0 - v_uv0.y) / tan(angleInRadians);\n    float offsetDis = abs(v_uv0.x - dx);\n    dis = sin(angleInRadians) * offsetDis;\n  } else {\n    dis = abs(v_uv0.y - lightCenterPoint.y);\n  }\n  float a = 1.0 ;\n  if (bool(cropAlpha)) {\n    a *= step(0.01, textureColor.a);\n  }\n  if (!bool(enableFog)) {\n    a *= step(dis, lightWidth * 0.5);\n  }\n  if (bool(enableGradient)) {\n    a *= 1.0 - dis / (lightWidth * 0.5);\n  }\n  vec4 finalLightColor = lightColor * a;\n  return textureColor * textureColor.a + finalLightColor;\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n  #if ENABLE_LIGHT\n  gl_FragColor = addLightColor(gl_FragColor, lightColor, lightCenterPoint, lightAngle, lightWidth);\n  #endif\n}"},"glsl1":{"vert":"\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}","frag":"\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\n#if ENABLE_LIGHT\nuniform vec4 lightColor;\nuniform vec2 lightCenterPoint;\nuniform float lightAngle;\nuniform float lightWidth;\nuniform float enableGradient;\nuniform float cropAlpha;\nuniform float enableFog;\nvec4 addLightColor(vec4 textureColor, vec4 lightColor, vec2 lightCenterPoint, float lightAngle, float lightWidth) {\n  if (lightWidth <= 0.0) {\n    return textureColor;\n  }\n  float angleInRadians = radians(lightAngle);\n  float dis = 0.0;\n  if (mod(lightAngle, 180.0) != 0.0) {\n    float lightOffsetX = lightCenterPoint.x - ((1.0 - lightCenterPoint.y) / tan(angleInRadians));\n    float dx = lightOffsetX + (1.0 - v_uv0.y) / tan(angleInRadians);\n    float offsetDis = abs(v_uv0.x - dx);\n    dis = sin(angleInRadians) * offsetDis;\n  } else {\n    dis = abs(v_uv0.y - lightCenterPoint.y);\n  }\n  float a = 1.0 ;\n  if (bool(cropAlpha)) {\n    a *= step(0.01, textureColor.a);\n  }\n  if (!bool(enableFog)) {\n    a *= step(dis, lightWidth * 0.5);\n  }\n  if (bool(enableGradient)) {\n    a *= 1.0 - dis / (lightWidth * 0.5);\n  }\n  vec4 finalLightColor = lightColor * a;\n  return textureColor * textureColor.a + finalLightColor;\n}\n#endif\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n  o *= texture2D(texture, v_uv0);\n    #if CC_USE_ALPHA_ATLAS_TEXTURE\n    o.a *= texture2D(texture, v_uv0 + vec2(0, 0.5)).r;\n    #endif\n  #endif\n  o *= v_color;\n  ALPHA_TEST(o);\n  gl_FragColor = o;\n  #if ENABLE_LIGHT\n  gl_FragColor = addLightColor(gl_FragColor, lightColor, lightCenterPoint, lightAngle, lightWidth);\n  #endif\n}"},"builtins":{"globals":{"blocks":[{"name":"CCGlobal","defines":[]}],"samplers":[]},"locals":{"blocks":[{"name":"CCLocal","defines":[]}],"samplers":[]}},"defines":[{"name":"USE_TEXTURE","type":"boolean","defines":[]},{"name":"CC_USE_MODEL","type":"boolean","defines":[]},{"name":"USE_ALPHA_TEST","type":"boolean","defines":[]},{"name":"ENABLE_LIGHT","type":"boolean","defines":[]},{"name":"CC_USE_ALPHA_ATLAS_TEXTURE","type":"boolean","defines":["USE_TEXTURE"]}],"blocks":[{"name":"ALPHA_TEST","binding":0,"members":[{"name":"alphaThreshold","type":13,"count":1}],"defines":["USE_ALPHA_TEST"]},{"name":"Light","binding":1,"members":[{"name":"lightColor","type":16,"count":1},{"name":"lightCenterPoint","type":14,"count":1},{"name":"lightAngle","type":13,"count":1},{"name":"lightWidth","type":13,"count":1},{"name":"enableGradient","type":13,"count":1},{"name":"cropAlpha","type":13,"count":1},{"name":"enableFog","type":13,"count":1}],"defines":["ENABLE_LIGHT"]}],"samplers":[{"name":"texture","type":29,"count":1,"binding":30,"defines":["USE_TEXTURE"]}]}],[{"passes":[{"program":"sprite-flash-light|vs|fs","blendState":{"targets":[{"blend":true}]},"rasterizerState":{"cullMode":0},"properties":{"texture":{"value":"white","type":29},"alphaThreshold":{"type":13,"value":[0.5]},"lightColor":{"type":16,"value":[1,1,0,1],"editor":{"type":"color","tooltip":"光束颜色"}},"lightCenterPoint":{"type":14,"value":[0.2,0.2],"editor":{"tooltip":"光束中心点坐标"}},"lightAngle":{"type":13,"value":[36],"editor":{"tooltip":"光束倾斜角度","range":[0,1]}},"lightWidth":{"type":13,"value":[0.2],"editor":{"tooltip":"光束宽度"}},"enableGradient":{"type":13,"value":[1],"editor":{"tooltip":"是否启用光束渐变。0：不启用，非0：启用"}},"cropAlpha":{"type":13,"value":[1],"editor":{"tooltip":"是否裁剪透明区域上的光。0：不启用，非0：启用"}},"enableFog":{"type":13,"value":[0],"editor":{"tooltip":"是否启用迷雾效果。0：不启用，非0：启用"}}}}]}]]],0,0,[],[],[]],[[[1,"sprite-gray",{"0":{"defines":{"USE_TEXTURE":true,"USE_GRAY":true}}}]],0,0,[0],[0],[14]],[[[1,"sprite-flag",{"0":{"defines":{"USE_TEXTURE":true}}}]],0,0,[0],[0],[15]],[[[1,"sprite-mosaic",{"0":{"props":{"xBlockCount":40,"yBlockCount":40},"defines":{"USE_TEXTURE":true,"USE_MOSAIC":true}}}]],0,0,[0],[0],[16]]]]